import numpy as np

"""
Sets up simulation classes to be reused in experiments.
"""

class Simulator:
    def __init__(self, N, D):
        """
        Initialize self and parameters for simulation.
        """

        self.N = N
        self.D = D

    def simulate(self):
        """
        Simulate data based on some parameters.

        Returns X (NxD), Y (Nx1), and Z (Nx1).
        """

        raise NotImplementedError("Subclasses must define this")


class LinearSimulator(Simulator):
    """
    Simulates data coming from a linear model. By default, this
    model is nonspatial. Subclasses add spatial effects.
    """

    def __init__(self, N, D):
        super().__init__(N, D)

    def simulate(self, beta, tau, eps_sd=0.1):
        """
        Generates linear outcome from nonspatial confounders and treatment.
        Y is generated linearly by adding X times the given confounder effects
        to Z times the treatment effect and adding an error term.

        beta       : confounder effects

        tau        : treatment effect

        eps_sd     : standard deviation of errors on the outcome
                     default = 0.1
        """

        if len(beta) != self.D:
            raise ValueError("beta must be a D-length vector")

        X, Z = self._create_data()
        eps_y = np.random.normal(loc=0, scale=eps_sd, size=(self.N, 1))
        Y = np.dot(X, beta) + tau * Z + eps_y
        return X, Y, Z

    def _create_data(self, treat_prob=0.5, x_sd=1):
        """
        Creates nonspatial data. X is generated by randomly choosing
        positive and negative integers in the interval [-2D, 2D] to use as
        means of normal distributions with SDs equal to x_sd (or elements of
        x_sd if it's a list). Z is an array of randomly assigned treatments
        according to treat_prob (N iid draws of Binomial(1, treat_prob)).

        Parameters
        ----------
        treat_prob : probability that a unit is treated
                     default = 0.5


        x_sd       : standard deviation of confounders
                     default = 1

        Returns
        -------
        X          : confounders
        Z          : treatment assigments
        """

        if np.ndim(x_sd) == 0:
            x_sd = np.repeat(x_sd, self.D)

        # Confounders
        means = np.random.choice(np.arange(-2*self.D, 2*self.D + 1, 1, dtype=int),
                                 size=self.D, replace=False)
        X = np.zeros((self.N, self.D))
        for d in range(self.D):
            X[:, d] = np.random.normal(loc=means[d], scale=x_sd[d], size=(self.N, 1))

        # Treatment assigned at random
        Z = np.random.binomial(1, treat_prob, size=(self.N, 1))

        return X, Z


class LinearAutoTreatment(LinearSimulator):
    def __init__(self, N, D):
        super().__init__(N, D)

    def simulate(self, beta, tau, rho=0.9, **kwargs):
        super().simulate(beta, tau, **kwargs)

    def _create_data(self, rho):
        pass

class LinearAutoOutcome(LinearSimulator):
    def __init__(self, N, D):
        super().__init__(N, D)

    def simulate(self, beta, tau, rho=0.9, **kwargs):
        super().simulate(beta, tau, **kwargs)

    def _create_data(self, rho):
        pass


class LinearAutoConfounder(LinearSimulator):
    def __init__(self, N, D):
        super().__init__(N, D)

    def simulate(self, beta, tau, rho=0.9, **kwargs):
        super().simulate(beta, tau, **kwargs)

    def _create_data(self, rho):
        pass
